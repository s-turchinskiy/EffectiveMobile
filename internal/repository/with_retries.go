// Code generated by gowrap. DO NOT EDIT.
// template: ../templates/retry
// gowrap: http://github.com/hexdigest/gowrap

package repository

//go:generate gowrap gen -p github.com/s-turchinskiy/EffectiveMobile/internal/repository -i Repository -t ../templates/retry -o with_retries.go -l ""

import (
	"context"

	"github.com/s-turchinskiy/EffectiveMobile/internal/models"

	"time"

	commonerrors "github.com/s-turchinskiy/EffectiveMobile/internal/common/errors"
)

// RepositoryWithRetry implements Repository interface instrumented with retries
type RepositoryWithRetry struct {
	Repository
	_retryInterval []time.Duration
}

// NewRepositoryWithRetry returns RepositoryWithRetry
func NewRepositoryWithRetry(base Repository, retryInterval []time.Duration) RepositoryWithRetry {
	return RepositoryWithRetry{
		Repository:     base,
		_retryInterval: retryInterval,
	}
}

// Close implements Repository
func (_d RepositoryWithRetry) Close(ctx context.Context) (err error) {

	if _d._retryInterval == nil || len(_d._retryInterval) == 0 {
		err = _d.Repository.Close(ctx)
		return
	}

	for _, delay := range _d._retryInterval {
		select {
		case <-ctx.Done():
			return
		default:
			time.Sleep(delay)
			err = _d.Repository.Close(ctx)
			if err == nil || !commonerrors.IsConnectionError(err) {
				return
			}
		}
	}
	return
}

// CreateSubscription implements Repository
func (_d RepositoryWithRetry) CreateSubscription(ctx context.Context, c2 models.CreateSubscription) (err error) {

	if _d._retryInterval == nil || len(_d._retryInterval) == 0 {
		err = _d.Repository.CreateSubscription(ctx, c2)
		return
	}

	for _, delay := range _d._retryInterval {
		select {
		case <-ctx.Done():
			return
		default:
			time.Sleep(delay)
			err = _d.Repository.CreateSubscription(ctx, c2)
			if err == nil || !commonerrors.IsConnectionError(err) {
				return
			}
		}
	}
	return
}

// DeleteSubscription implements Repository
func (_d RepositoryWithRetry) DeleteSubscription(ctx context.Context, id uint64) (err error) {

	if _d._retryInterval == nil || len(_d._retryInterval) == 0 {
		err = _d.Repository.DeleteSubscription(ctx, id)
		return
	}

	for _, delay := range _d._retryInterval {
		select {
		case <-ctx.Done():
			return
		default:
			time.Sleep(delay)
			err = _d.Repository.DeleteSubscription(ctx, id)
			if err == nil || !commonerrors.IsConnectionError(err) {
				return
			}
		}
	}
	return
}

// GetSubscriptions implements Repository
func (_d RepositoryWithRetry) GetSubscriptions(ctx context.Context) (ra1 []models.ReadSubscriptionJSON, err error) {

	if _d._retryInterval == nil || len(_d._retryInterval) == 0 {
		ra1, err = _d.Repository.GetSubscriptions(ctx)
		return
	}

	for _, delay := range _d._retryInterval {
		select {
		case <-ctx.Done():
			return
		default:
			time.Sleep(delay)
			ra1, err = _d.Repository.GetSubscriptions(ctx)
			if err == nil || !commonerrors.IsConnectionError(err) {
				return
			}
		}
	}
	return
}

// SumSubscriptions implements Repository
func (_d RepositoryWithRetry) SumSubscriptions(ctx context.Context, data models.SumSubscriptions) (u1 uint64, err error) {

	if _d._retryInterval == nil || len(_d._retryInterval) == 0 {
		u1, err = _d.Repository.SumSubscriptions(ctx, data)
		return
	}

	for _, delay := range _d._retryInterval {
		select {
		case <-ctx.Done():
			return
		default:
			time.Sleep(delay)
			u1, err = _d.Repository.SumSubscriptions(ctx, data)
			if err == nil || !commonerrors.IsConnectionError(err) {
				return
			}
		}
	}
	return
}

// UpdateSubscription implements Repository
func (_d RepositoryWithRetry) UpdateSubscription(ctx context.Context, u1 models.UpdateSubscription) (err error) {

	if _d._retryInterval == nil || len(_d._retryInterval) == 0 {
		err = _d.Repository.UpdateSubscription(ctx, u1)
		return
	}

	for _, delay := range _d._retryInterval {
		select {
		case <-ctx.Done():
			return
		default:
			time.Sleep(delay)
			err = _d.Repository.UpdateSubscription(ctx, u1)
			if err == nil || !commonerrors.IsConnectionError(err) {
				return
			}
		}
	}
	return
}
